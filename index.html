begin;

-- =========================
-- Tables (idempotent)
-- =========================
create table if not exists public.users (
  id uuid primary key,
  email text not null unique,
  name text not null,
  student_id text,
  team text,
  year int,
  created_at timestamptz default now()
);

create table if not exists public.events (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  lat_min double precision not null,
  lat_max double precision not null,
  lng_min double precision not null,
  lng_max double precision not null,
  start_time timestamptz not null,
  end_time timestamptz not null,
  points int default 0,
  location text
);

create table if not exists public.checkins (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null,
  event_id uuid not null references public.events(id) on delete cascade,
  created_at timestamptz default now()
);

create unique index if not exists checkins_user_event_idx
  on public.checkins (user_id, event_id);

-- Ensure checkins FK is resilient
alter table public.checkins drop constraint if exists checkins_user_id_fkey;
alter table public.checkins
  add constraint checkins_user_id_fkey
  foreign key (user_id) references public.users(id)
  on update cascade on delete cascade;

-- =========================
-- RLS & Policies (idempotent)
-- =========================
alter table public.users    enable row level security;
alter table public.events   enable row level security;
alter table public.checkins enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='events' and policyname='events_select_authenticated'
  ) then
    create policy events_select_authenticated on public.events
      for select to authenticated using (true);
  end if;
end $$;

do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='checkins' and policyname='checkins_select_own'
  ) then
    create policy checkins_select_own on public.checkins
      for select to authenticated using (user_id = auth.uid());
  end if;
end $$;

do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='checkins' and policyname='checkins_insert_own'
  ) then
    create policy checkins_insert_own on public.checkins
      for insert to authenticated with check (user_id = auth.uid());
  end if;
end $$;

do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='users' and policyname='users_select_self'
  ) then
    create policy users_select_self on public.users
      for select to authenticated using (id = auth.uid());
  end if;
end $$;

do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='users' and policyname='users_insert_self'
  ) then
    create policy users_insert_self on public.users
      for insert to authenticated with check (id = auth.uid());
  end if;
end $$;

do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='users' and policyname='users_update_self'
  ) then
    create policy users_update_self on public.users
      for update to authenticated
      using (id = auth.uid()) with check (id = auth.uid());
  end if;
end $$;

-- =========================
-- student_id optional + unique when present
-- =========================
alter table public.users
  alter column student_id drop not null;

do $$
declare conname text;
begin
  select constraint_name into conname
  from information_schema.table_constraints
  where table_schema='public' and table_name='users'
    and constraint_type='UNIQUE' and constraint_name like '%student_id%';
  if conname is not null then
    execute format('alter table public.users drop constraint %I', conname);
  end if;
end $$;

create unique index if not exists users_student_id_unique_not_null
  on public.users (lower(student_id))
  where student_id is not null;

update public.users set student_id = null where student_id = '';

-- =========================
-- Events PST/UTC helpers
-- =========================
alter table public.events
  add column if not exists start_time_pst timestamp,
  add column if not exists end_time_pst   timestamp;

alter table public.events
  add column if not exists start_time_utc timestamptz
    generated always as (start_time_pst at time zone 'America/Los_Angeles') stored,
  add column if not exists end_time_utc timestamptz
    generated always as (end_time_pst   at time zone 'America/Los_Angeles') stored;

update public.events
set start_time_pst = coalesce(start_time_pst, (start_time at time zone 'America/Los_Angeles')),
    end_time_pst   = coalesce(end_time_pst,   (end_time   at time zone 'America/Los_Angeles'))
where start_time_pst is null or end_time_pst is null;

create index if not exists events_start_time_utc_idx on public.events (start_time_utc);

-- =========================
-- Single canonical trigger to create profile rows
-- =========================
drop trigger if exists on_auth_user_created on auth.users;
drop function if exists public.handle_new_user();

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $fn$
begin
  insert into public.users (id, email, name, student_id, team, year, created_at)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'name',''),
    nullif(new.raw_user_meta_data->>'student_id',''),
    nullif(new.raw_user_meta_data->>'team',''),
    nullif((new.raw_user_meta_data->>'year')::int, null),
    now()
  )
  on conflict (id) do nothing;
  return new;
end;
$fn$;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

-- =========================
-- TEMP disable public.users triggers, align IDs, re-enable
-- (prevents "id is immutable" while we repair)
-- =========================
alter table public.users disable trigger all;

-- Align every public.users.id to its auth.users.id by email
update public.users u
set id = au.id
from auth.users au
where u.email = au.email
  and u.id <> au.id;

-- Backfill any missing profiles from auth.users (by id)
insert into public.users (id, email, name, student_id, team, year, created_at)
select
  au.id,
  au.email,
  coalesce(au.raw_user_meta_data->>'name',''),
  nullif(au.raw_user_meta_data->>'student_id',''),
  nullif(au.raw_user_meta_data->>'team',''),
  nullif((au.raw_user_meta_data->>'year')::int, null),
  now()
from auth.users au
left join public.users u on u.id = au.id
where u.id is null;

alter table public.users enable trigger all;

-- =========================
-- Add cross-schema FK AFTER alignment; validate
-- =========================
alter table public.users drop constraint if exists users_id_fk_auth;
alter table public.users
  add constraint users_id_fk_auth
  foreign key (id) references auth.users(id)
  on delete cascade
  not valid;

-- Validate (will check existing rows)
alter table public.users validate constraint users_id_fk_auth;

commit;
